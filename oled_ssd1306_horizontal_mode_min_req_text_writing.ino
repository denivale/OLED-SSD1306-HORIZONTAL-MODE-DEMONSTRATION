#include <Wire.h>
// OLED SSD1306 address
#define OLED_ADDRESS 0x3C

// Command constants for the OLED display
#define OLED_CONTROL_BYTE_CMD 0x00
#define OLED_CONTROL_BYTE_CMD_MULTIPLE 0x80
#define OLED_CONTROL_BYTE_DATA 0x40
#define OLED_CONTROL_BYTE_DATA_MULTIPLE 0xC0 //not working?!

// Display width and height in pixels
#define OLED_WIDTH 128
#define OLED_HEIGHT 64

// List of characters used for demonstration
const char Fontmap[] = {
  ' ', '!','\"','#', '$', '%', '&', '\'', 
  '(' ,')', '*', '+', ',', '-', '.', '/',
  '0','1','2','3','4','5','6','7','8','9',
  'A','B','C','D','E','F','G','H','I','J',
  'K','L','M','N','O','P','Q','R','S','T',
  'U', 'V', 'W', 'X', 'Y', 'Z'
};

// Fonts
const byte font[][8] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  // space
  { 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00 },  // !
  { 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00 },  // "
  { 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00 },  // #
  { 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00 },  // $
  { 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00 },  // %
  { 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00 },  // &
  { 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },  // '
  { 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00 },  // (
  { 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00 },  // )
  { 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00 },  // *
  { 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00 },  // +
  { 0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 },  // ,
  { 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },  // -
  { 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },  // .
  { 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00 },  // /
  { 0x7E, 0x81, 0x95, 0xB1, 0xB1, 0x95, 0x81, 0x7E },  // 0 //actually :)
  { 0x00, 0x42, 0x7F, 0x40, 0x40, 0x00, 0x00, 0x00 },  // 1
  { 0x62, 0x51, 0x49, 0x49, 0x49, 0x46, 0x00, 0x00 },  // 2
  { 0x22, 0x41, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00 },  // 3
  { 0x0F, 0x08, 0x08, 0x7E, 0x08, 0x08, 0x00, 0x00 },  // 4
  { 0x4F, 0x49, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00 },  // 5
  { 0x3E, 0x49, 0x49, 0x49, 0x49, 0x32, 0x00, 0x00 },  // 6
  { 0x01, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00 },  // 7
  { 0x36, 0x49, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00 },  // 8
  { 0x06, 0x49, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00 },  // 9
  { 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00 },  // A
  { 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00 },  // B
  { 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00 },  // C
  { 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00 },  // D
  { 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00 },  // E
  { 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00 },  // F
  { 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00 },  // G
  { 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00 },  // H
  { 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00 },  // I
  { 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00 },  // J
  { 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00 },  // K
  { 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00 },  // L
  { 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00 },  // M
  { 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00 },  // N
  { 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00 },  // O
  { 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00 },  // P
  { 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00 },  // Q
  { 0x7F, 0x09, 0x09, 0x09, 0x7E, 0x40, 0x00, 0x00 },  // R
  { 0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00 },  // S
  { 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00 },  // T
  { 0x7F, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00 },  // U
  { 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00 },  // V
  { 0x7F, 0x20, 0x10, 0x20, 0x7F, 0x00, 0x00, 0x00 },  // W
  { 0x41, 0x22, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00 },  // X
  { 0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00 },  // Y
  { 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00 }   // Z
};


// Horizontal mode
void horizontalExample(){//minimal requirments
  Wire.beginTransmission(OLED_ADDRESS);
  Wire.write(OLED_CONTROL_BYTE_CMD_MULTIPLE);  
  Wire.write(0xAE);
  Wire.write(0x20); /// address mode
  Wire.write(0x00); // Horizontal
  Wire.write(0xA4);
  Wire.write(0xAF);
  Wire.write(0x22); //Set page address range
  Wire.write(0);
  Wire.write(7);
  Wire.write(0x21); // column start and end address
  Wire.write(0);
  Wire.write(127);
  Wire.endTransmission();
  }

// Mapping between font and particular character;
// returns character order in list
int getChar(char c){
  int i = 0;
  while(c != Fontmap[i]){
    ++i;
  }
  return i;
}

// Write empty pixels - area 16x8
// One can send maximum of 32 data frames (control byte included)
void fastClearLargestPartAtOnce(){
  Wire.beginTransmission(OLED_ADDRESS);
  Wire.write(OLED_CONTROL_BYTE_DATA);
  for (int j = 0; j < 16; j++) {
    Wire.write(0x00);
  }
  Wire.endTransmission();
  return;
}

//Clear screen and return to the last position on screen
void fastClear(){
  for (int i = 0; i < OLED_HEIGHT/8; i++)
    for (int j = 0; j < 8; j++)
      fastClearLargestPartAtOnce();          
}


//Setting start line
void setStartLine(byte row){
  Wire.beginTransmission(OLED_ADDRESS);
  Wire.write(0x00);
  Wire.write(0x40+row);
  Wire.endTransmission();  
}

//Write text on the screen from the last
//known position
void writeText(char* text) {
  int len = strlen(text);
  int loc;
  for (int i = 0; i < len; i++) {
    loc = getChar(text[i]);
    Wire.beginTransmission(OLED_ADDRESS);
    Wire.write(OLED_CONTROL_BYTE_DATA);
    for (int j = 0; j < 8; j++) {
      Wire.write(font[loc][j]);
    }
    Wire.endTransmission();
  }
}


void setup() {
  // initialize I2C as master device
  Wire.begin();
  
  // initialize OLED SSD1306 screen in horizontal mode
  horizontalExample();
  delay(10);

  // set start line
  setStartLine(0);
  delay(10);

  // Clear screen from leftover characters
  fastClear();
  
  // write text  
  writeText("HELLO WORLD!!!");
  
}

void loop() {
  // Empty
}

